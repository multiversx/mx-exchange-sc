// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct SimpleLockEnergyProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for SimpleLockEnergyProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = SimpleLockEnergyProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        SimpleLockEnergyProxyMethods { wrapped_tx: tx }
    }
}

pub struct SimpleLockEnergyProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> SimpleLockEnergyProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Args: 
    /// - base_asset_token_id: The only token that is accepted for the lockTokens endpoint. 
    ///     NOTE: The SC also needs the ESDTLocalMint and ESDTLocalBurn roles for this token. 
    /// - legacy_token_id: The token ID of the old locked asset. 
    ///     NOTE: The SC also needs the NFTBurn role for this token. 
    /// - old_locked_asset_factory_address 
    /// - min_migrated_token_locked_period - The minimum number of epochs that 
    ///     a migrated old LKMEX token will be locked for after the average is calculated 
    /// - lock_options: See `addLockOptions` endpoint doc for details. 
    pub fn init<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<u64>,
        Arg4: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<u64, u64>>>,
    >(
        self,
        base_asset_token_id: Arg0,
        legacy_token_id: Arg1,
        old_locked_asset_factory_address: Arg2,
        min_migrated_token_locked_period: Arg3,
        lock_options: Arg4,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&base_asset_token_id)
            .argument(&legacy_token_id)
            .argument(&old_locked_asset_factory_address)
            .argument(&min_migrated_token_locked_period)
            .argument(&lock_options)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> SimpleLockEnergyProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> SimpleLockEnergyProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Locks a whitelisted token until `unlock_epoch` and receive meta ESDT LOCKED tokens 
    /// on a 1:1 ratio. Accepted input tokens: 
    /// - base asset token 
    /// - old factory token -> extends all periods to the provided option 
    /// - previously locked token -> extends period to the provided option 
    ///  
    /// Arguments: 
    /// - lock_epochs - Number of epochs for which the tokens are locked for. 
    ///     Caller may only choose from the available options, 
    ///     which can be seen by querying getLockOptions 
    /// - opt_destination - OPTIONAL: destination address for the LOCKED tokens. Default is caller. 
    ///  
    /// Output payment: LOCKED tokens 
    pub fn lock_tokens_endpoint<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        lock_epochs: Arg0,
        opt_destination: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("lockTokens")
            .argument(&lock_epochs)
            .argument(&opt_destination)
            .original_result()
    }

    /// Unlock tokens, previously locked with the `lockTokens` endpoint 
    ///  
    /// Expected payments: LOCKED tokens 
    ///  
    /// Output payments: the originally locked tokens 
    pub fn unlock_tokens_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("unlockTokens")
            .original_result()
    }

    /// Used internally by proxy-dex 
    pub fn extend_lock_period<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        lock_epochs: Arg0,
        user: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("extendLockPeriod")
            .argument(&lock_epochs)
            .argument(&user)
            .original_result()
    }

    pub fn issue_locked_token<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<usize>,
    >(
        self,
        token_display_name: Arg0,
        token_ticker: Arg1,
        num_decimals: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issueLockedToken")
            .argument(&token_display_name)
            .argument(&token_ticker)
            .argument(&num_decimals)
            .original_result()
    }

    pub fn locked_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLockedTokenId")
            .original_result()
    }

    pub fn base_asset_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseAssetTokenId")
            .original_result()
    }

    pub fn legacy_locked_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLegacyLockedTokenId")
            .original_result()
    }

    pub fn get_updated_energy_entry_for_user<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Energy<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEnergyEntryForUser")
            .argument(&user)
            .original_result()
    }

    pub fn get_energy_amount_for_user<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEnergyAmountForUser")
            .argument(&user)
            .original_result()
    }

    pub fn set_energy_for_user<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<i64>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        user: Arg0,
        energy_amount: Arg1,
        total_locked_tokens: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_energy_for_user")
            .argument(&user)
            .argument(&energy_amount)
            .argument(&total_locked_tokens)
            .original_result()
    }

    /// Add lock options, as pairs of epochs and penalty percentages. 
    /// lock epochs must be >= 360 epochs (1 year), 
    /// percentages must be between 0 and 10_000 
    /// Additionally, percentages must increase as lock period increases. 
    ///  
    /// For example, an option pair of "360, 100" means the user can choose to lock their tokens 
    /// for 360 epochs, and if they were to unlock the immediately, 
    /// they would incur a penalty of 1%. 
    ///  
    /// When calling lockTokens, or reducing lock periods, 
    /// users may only pick one of the whitelisted lock options. 
    pub fn add_lock_options<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<u64, u64>>>,
    >(
        self,
        new_lock_options: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addLockOptions")
            .argument(&new_lock_options)
            .original_result()
    }

    pub fn get_lock_options_view(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ArrayVec<LockOption, 10usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLockOptions")
            .original_result()
    }

    /// Unlock a locked token instantly. This incures a penalty. 
    /// The longer the remaining locking time, the bigger the penalty. 
    /// Tokens can be unlocked through another SC after the unbond period has passed. 
    pub fn unlock_early(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("unlockEarly")
            .original_result()
    }

    /// Reduce the locking period of a locked token. This incures a penalty. 
    /// The longer the reduction, the bigger the penalty. 
    /// new_lock_period must be one of the available lock options 
    pub fn reduce_lock_period<
        Arg0: ProxyArg<u64>,
    >(
        self,
        new_lock_period: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("reduceLockPeriod")
            .argument(&new_lock_period)
            .original_result()
    }

    /// Calculates the penalty that would be incurred if `token_amount` tokens 
    /// were to have their lock epochs reduced from `prev_lock_epochs` to 
    /// `new_lock_epochs`. For full unlock, `new_lock_epochs` should be 0. 
    pub fn calculate_penalty_amount<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        token_amount: Arg0,
        prev_lock_epochs: Arg1,
        new_lock_epochs: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPenaltyAmount")
            .argument(&token_amount)
            .argument(&prev_lock_epochs)
            .argument(&new_lock_epochs)
            .original_result()
    }

    /// - token_unstake_address - The address of the SC that will handle the unbond logic 
    ///     By default, all tokens go through an unbond period after unlock 
    pub fn set_token_unstake_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        sc_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTokenUnstakeAddress")
            .argument(&sc_address)
            .original_result()
    }

    pub fn revert_unstake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<Energy<Env::Api>>,
    >(
        self,
        user: Arg0,
        new_energy: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("revertUnstake")
            .argument(&user)
            .argument(&new_energy)
            .original_result()
    }

    pub fn token_unstake_sc_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenUnstakeScAddress")
            .original_result()
    }

    /// Sets the energy amounts and token amounts for users. Overwrites any existing values. 
    /// Expects any number of pairs of (user address, token amount, energy amount). 
    pub fn set_energy_for_old_tokens<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue3<ManagedAddress<Env::Api>, BigUint<Env::Api>, BigInt<Env::Api>>>>,
    >(
        self,
        users_energy: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setEnergyForOldTokens")
            .argument(&users_energy)
            .original_result()
    }

    pub fn update_energy_after_old_token_unlock<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<common_structs::locked_token_types::UnlockEpochAmountPairs<Env::Api>>,
        Arg2: ProxyArg<common_structs::locked_token_types::UnlockEpochAmountPairs<Env::Api>>,
    >(
        self,
        original_caller: Arg0,
        initial_epoch_amount_pairs: Arg1,
        final_epoch_amount_pairs: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateEnergyAfterOldTokenUnlock")
            .argument(&original_caller)
            .argument(&initial_epoch_amount_pairs)
            .argument(&final_epoch_amount_pairs)
            .original_result()
    }

    pub fn migrate_old_tokens(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValueEncoded<Env::Api, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("migrateOldTokens")
            .original_result()
    }

    pub fn pause_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pause")
            .original_result()
    }

    pub fn unpause_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpause")
            .original_result()
    }

    pub fn paused_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isPaused")
            .original_result()
    }

    /// Sets the transfer role for the given address. Defaults to own address. 
    pub fn set_transfer_role<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTransferRoleLockedToken")
            .argument(&opt_address)
            .original_result()
    }

    /// Sets the burn role for the given address 
    pub fn set_burn_role<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBurnRoleLockedToken")
            .argument(&address)
            .original_result()
    }

    pub fn set_self_roles<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, EsdtLocalRole>>,
    >(
        self,
        token_id: Arg0,
        roles: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setSelfRoles")
            .argument(&token_id)
            .argument(&roles)
            .original_result()
    }

    pub fn set_locked_token_id<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_locked_token_id")
            .argument(&token_id)
            .original_result()
    }

    pub fn merge_tokens_endpoint<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_original_caller: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mergeTokens")
            .argument(&opt_original_caller)
            .original_result()
    }

    pub fn lock_virtual<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        token_id: Arg0,
        amount: Arg1,
        lock_epochs: Arg2,
        dest_address: Arg3,
        energy_address: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("lockVirtual")
            .argument(&token_id)
            .argument(&amount)
            .argument(&lock_epochs)
            .argument(&dest_address)
            .argument(&energy_address)
            .original_result()
    }

    pub fn add_sc_address_to_whitelist<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addSCAddressToWhitelist")
            .argument(&address)
            .original_result()
    }

    pub fn remove_sc_address_from_whitelist<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeSCAddressFromWhitelist")
            .argument(&address)
            .original_result()
    }

    pub fn is_sc_address_whitelisted<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isSCAddressWhitelisted")
            .argument(&address)
            .original_result()
    }

    pub fn add_to_token_transfer_whitelist<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        sc_addresses: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addToTokenTransferWhitelist")
            .argument(&sc_addresses)
            .original_result()
    }

    pub fn remove_from_token_transfer_whitelist<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        sc_addresses: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeFromTokenTransferWhitelist")
            .argument(&sc_addresses)
            .original_result()
    }

    pub fn set_user_energy_after_locked_token_transfer<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<Energy<Env::Api>>,
    >(
        self,
        user: Arg0,
        energy: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setUserEnergyAfterLockedTokenTransfer")
            .argument(&user)
            .argument(&energy)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq, Debug)]
pub struct Energy<Api>
where
    Api: ManagedTypeApi,
{
    pub amount: BigInt<Api>,
    pub last_update_epoch: u64,
    pub total_locked_tokens: BigUint<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct LockOption {
    pub lock_epochs: u64,
    pub penalty_start_percentage: u64,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct EnergyUpdatedEvent<Api>
where
    Api: ManagedTypeApi,
{
    pub old_energy_entry: Energy<Api>,
    pub new_energy_entry: Energy<Api>,
}
